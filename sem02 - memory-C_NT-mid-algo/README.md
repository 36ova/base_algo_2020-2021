# Семинар второй

## Работа с памятью в C++

В качестве вступления, приведу несколько цитат о языке C++:

* Writing in C or C++ is like running a chain saw with all the safety guards removed.
(Bob Gray of consulting firm Virtual Solutions; cited in Byte (1998) Vol 23, Nr 1-4. p. 70)

* C gives the programmer what the programmer wants; few restrictions, few complaints... C++ maintains the original spirit of C, that the programmer not the language is in charge.
(Herbert Schildt (2002) C++: The Complete Reference, 4th Edition. p. 8)

* In C++ it's harder to shoot yourself in the foot, but when you do, you blow off your whole leg.
(Bjarne Stroustrup "Stroustrups FAQ" research.att.com; Cited in: Charles R. Hardnett (2011) Programming Like a Pro for Teens. p. 295)

### Типы памяти

В C++ три вида памяти: стековый, динамический (автоматический) и статический. Поговорим про них подробнее.

#### Стековая память

Она очень маленькая по размеру (порядка нескольких мегабайт), выделяется **до** старта работы программы. На ней размещаются локальные переменные, которые быстро затираются, как только выйти из их области действия. Еще на стеке хранится информация о вызове функций (аргументы, блок, куда надо вернуться). Например, известная ошибка переполнение стека (stack overflow) чаще всего связана с тем, что функция вызывается рекурсивно без остановки.

При этом работает она быстро, так как стек сам по себе написан так, чтобы быстро добавлять или удалять элементы.

#### Статическая память

Эта область памяти по размерам еще меньше, чем стековая. В ней хранятся данные, доступные на протяжении работы всей программы. В C++ в ней обычно хранятся глобальные и статические переменные.

#### Динамическая память (или куча)

Она уже достаточно большая (вся доступная оперативная память), выделяется по мере запроса к операционной системе. На ней можно размещать различные массивы больших размеров. Чисто теоретически, она доступна, пока программа работает. Но если программа расходует много памяти, хотя единовременно ей много и не надо (то есть вы не освобождаете ее по мере ненадобности), то может не хватить оперативки и будет все очень печально. После окончания работы программы менеджер памяти (часть ОС, регулирующая использование оперативки) освободит все, что вы от него запрашивали.

Так как менеджер памяти регулирует использование всей оперативной памяти, его работа малость дольше, чем работа стековой памяти. [Тут](https://gist.github.com/hellerbarde/2843375) можно сравнить скорость работы различных операций с памятью.

В качестве упражнения, можете исследовать, сколько оперативной памяти у вас имеется при различном наборе открытых программ. Сделать это можно с помощью оператора new, так как если память не удастся выделить, то он вернет nullptr.

Здесь стоит сделать лирическое отступление о сборщике мусора или о *garbage collector*. Сборщик мусора - это модуль, суть которого в том, чтобы смотреть, какая оперативная память, запрошенная вами, уже не используется и освобождать ее. То есть это ваш помощник, который реализован во многих языках программирования, например, Python. К сожалению, удобство никогда не было бесплатным, поэтому приходится жертвовать производительностью в таких языках. В C++ нет его, так как этот язык позволяет вам сделать все, но отвечать за содеянное будете только вы.

У динамической памяти есть понятие адреса. Грубо говоря, адрес в памяти говорит о том, где лежит выделенная вами память. Для работы с ними нужны указатели.

### Указатели в C++

В C++ при создании любой переменной ей выделяется место в памяти, а значит и выдается ее адрес. Вообще, компилятор работает с адресами, а не с именами переменных.

Указатель - переменная, которая хранит в себе адрес объекта, на который он указывает. В 32-битных архитектурах его размер составляет 4 байта, в 64-битных - 8 байт.

Есть еще указатель `nullptr`, который указывает на специальный адрес, который говорит, что под ним ничего нет. То есть как бы пустота, с которой ничего нельзя делать.

#### Оператор &

Чтобы создать указатель на что-либо, нужен адрес объекта, на что ему надо указывать. Для этого и нужен оператор взятия адреса или &. Вот пример объявления указателя

```cpp
int a = 1;
int* ptr = &a; //int* - pointer on int
               //&a - returns address in memory of variable a
std::cout << ptr; //not 1! you will see address of a (for example, 0x7ffff39b9ea4)
````

Как можно видеть из примера, оператор & возвращает тип указателя.

#### Оператор *

Создавать указатели и получать адреса объектов это конечно классно, но как получать значения того, что лежит под указателем. Для этого и нужен оператор * или разыменования. Он по сути дает нам доступ к модификации памяти, которая лежит под указателем (про константность будет далее).

```cpp
int a = 1;
int* ptr = &a;     //int* - pointer on int
                   //&a - returns address in memory of variable a
std::cout << *ptr; //1
a = 2;
std::cout << *ptr; //2, because *ptr is like variable a
*ptr = 3;          //a == *ptr
std::cout << *ptr; //3
````

#### Арифметические операции

Указатели можно вычитать друг из друга. Результатом будет сдвиг одного относительного другого в виде количества байтов между ними, деленное на размер типа. Как следствие, нельзя вычитать указатели разных типов друг из друга.

Также к указателям можно прибавлять/отнимать целые числа (*n*), то есть сдвигать их на *n * sizeof(type* байт.

```cpp
int a = 0;
int* p1 = &a;
int* p2 = p1 + 1;     //now p2 points to p1 + 1 * sizeof(int) bytes or p1 + 4 bytes
std::cout << p2 - p1; //4 bytes / sizeof(int) is 1
                      //it means that between p2 and p1 only one int
````

#### Сравнение указателей

Указатели можно проверять на равенство (если адреса объектов, на которые они указывают, совпадут, то вернется true). Тут как раз удобно сравнение с `nullptr`, о применениях которого поговорим чуть позже.

Также указатели можно сравнивать на отношение больше/меньше. Указатель больше другого, если его адрес больше (не забываем, что это просто 32/64-битное число в 16-ричной системе счисления).

#### А как работать с динамической памятью?

Заметим, что во всех примерах выше мы работали с указателями на переменные в стековой памяти. Настало время расширить границы и добраться до оперативной памяти. Для работы с ней есть операторы `new` и `delete`.

Оператор `new` нужен для того, чтобы запросить память у менеджера памяти. Он возвращает указатель на область памяти, если ему удалось выделить ее и `nullptr` иначе.

Оператор `delete` нужен для того, чтобы освободить память для дальнейшего ее переиспользования нашей программой или другим приложением.

```cpp
double* ptr1 = new double;
double* ptr2 = new double(3.14); //*ptr == 3.14
std::cout << *ptr1 << '\n'; //under ptr1 we have trash, so it could be any value
std::cout << *ptr2 << '\n'; //under ptr2 we have 3.14 value
delete ptr1; //you free 8 bytes for your OS! You are breathtaking!
delete ptr2; //if you don't free memory, you'll be bad person, because you'll have memory leak
````

В языке Си вы могли пользоваться связкой операторов `malloc` и `free`. Это конечно классные операторы, но не нужно ими пользоваться, так как C++ дает куда больше гарантий на использование операторов `new` и `delete`. Более того, во втором семестре мы с вами вообще отойдем от использования и этих операторов!

#### Двойное удаление

```cpp
double* ptr1 = new double(1.0);
delete ptr1; //you are great!
delete ptr1; //oops, you double free memory:(
````

Что же произошло? В первой строке вы создали указатель, а во второй его освободили. К сожалению, вы попытались освободить память, которая уже вам не принадлежит. Вдруг ее забрала уже себе ваша IDE. Некруто будет все сломать, по глупости удалив не то. Хорошо, что менеджер памяти - ваш друг, поэтому он не позволит вам залезть не в вашу память, а просто аварийно завершит вашу программу.

```cpp
double* a = new double(1.0);
double* b = a;
delete a; //you are great!
delete b; //oops, you double free memory:(
````
А в данном примере все малость труднее. Проблема в том, что хоть переменные и разные, но указывают они на одну и ту же область памяти. Так что первое удаление автоматически делает невалидным сторой указатель.

В данных примерах мы пришли к новому типу ошибок - ошибка исполнения (runtime error или re). Операции с памятью компилятор не способен отслеживать, поэтому это не будет ошибкой компиляции. Но в ходе исполнения вы словили крайне неприятную багу, которая в лучшем случае просто аварийно остановит вашк программу. Более того, менеджер памяти любезно скажет вам, что вы два раза удалили один и тот же указатель. Даже укажет адрес))

Для отлавливания утечек памяти и прочих ошибок памяти имеется утилита valgrind. К сожалению, она есть только под linux и под старые версии Mac OS. 

## Массивы в C++

Пришло время познакомиться с тем, как устроены массивы в языке C++. Да, вы долго этого ждали, но радоваться рано. Тут самое время вспомнить цитаты из введения, так как мы переходим к теме, где есть куча мест, чтобы выстрелить себе в ногу.

Массивы в C++ неразрывно связаны с указателями. Для простоты рассмотрим пример

```cpp
int* array = new int[3];
for (int i = 0; i < 3; ++i) {
  array[i] = i * i;
}
delete[] array;
````

* `new int[3];` Тут мы просим менеджер памяти выделить нам массив из интов длины три. Его элементы будут распологаться последовательно в памяти. При этом вернется указатель на нулевой элемент массива (да, живем в 0-индексации). На данный момент под этими указателями лежит какой-то мусор.

* `int* array = new int[3];` На данный момент переменная *array* - указатель на нулевой элемент массива.

* `array[i] = i * i;` Эта строка равносильна следующей `*(array + i) = i * i;`. То есть мы говорим, что под i-м элементом в памяти мы хотим записать нужное нам значение. Вот и связь указателей и массивов.

* `delete[] array;` Это самая важная строка данного кода. Оператор `delete[]` говорит о том, что нужно освободить **не только нулевой элемент массива, а весь массив**.

Проблема двойного удаления или забывчивости удаления тут актуальна как никогда, так что "берегите ноги, господа".

### I have pointers, I have const...

Так как язык C++ велик и могуч, можно создавать как константные указатели, так и указатели на константу.

#### Константные указатели

Константный указатель говорит о том, что **можно** менять элементы под указателем, но **нельзя** изменять адрес, куда указатель указывает. Вот и пример

```cpp
int* const array = new int[3];
int* ptr = new int[3];
array = ptr; //CE you can't modify address of array, because it is const
````

#### Указатели на константу

Указатель на константу говорит о том, что **можно** менять адрес, куда указатель указывает, но **нельзя** менять элементы под указтелем. Вот и пример

```cpp
const int* p = new int(1);
*p = 0; //CE, you can't modify element under pointer
````

Казалось бы, зачем нам это надо все? Если первое скорее для красоты, то второе позволяет создавать неизменяемые массивы!

```cpp
const int* array = new int[3]{1, 2, 3};
std::cout << array[0];//1
array[2] = 5; //CE, you can't modify elements under pointer
delete[] array;
````
* В первой строке пример создания массива на три элемента, в котором сразу проинициализированы элементы. Это забавная конструкция языка C++. Она позволяет создать константый массив, в котором не лежит мусор, а уже заданы значения.

* В третьей строке мы попытались поменять значение по индексу, но это запрещено. Это может показаться странным, но развернем оператор квадратные скобки: это строка `*(array + 2) = 5;`. Проблема в том, что `*(array + 2)` вернет константый указатель.

### Многомерные массивы

Нам иногда надо хранить не просто массив или список элементов, а целую матрицу! Для такого существуют многомерные массивы, которые являются массивами массивов. А вот и пример создания, инициализации и печати такой красоты.

```cpp
int** matrix = new int*[3];
for (int i = 0; i < 3; ++i) {
  matrix[i] = new int[3];
}

for (int i = 0; i < 3; ++i) {
  for (int j = 0; j < 3; ++j) {
    matrix[i][j] = i + j;
  }
}

for (int i = 0; i < 3; ++i) {
  for (int j = 0; j < 3; ++j) {
    std::cout << matrix[i][j] << ' ';
  }
  std::cout << '\n';
}

for (int i = 0; i < 3; ++i) {
  delete[] matrix[i];
}
delete[] matrix;
````

Теперь давайте разбирать, что написано в данном коде.

* `new int*[3]` Мы создаем массив из трех указателей на int. Тогда это как бы указатель на укзатель на int, то есть тип int**

* `int** matrix = new int*[3];` Теперь matrix является массивом из указателей.

* Далее идет цикл for, который делает каждый из указателей массивом длины три.

* Далее идет цикл, который пробегается по всем элементам матрицы. Посмотрим, как раскрывать квадратные скобки в таком случае. `matrix[i][j]` это то же самое, что и `*(matrix[i] + j)` или же `*(*(matrix + i) + j)`. И да, если вам захочется понавешать где-нибудь на стадии инициализации *const*, то вы почти наверное "прострелите себе ногу".

* Далее цикл с красивым выводом. В итоге в консоли вы увидите это

0 1 2 
1 2 3 
2 3 4

* Время удаления. Допустим, вы не удалили в цикле каждый массив, а оставили только последнюю строку. Попробуйте после такого заполучить `matrix[2][2]`, а потом обдумайте, что пошло не так.

Поэтому необходимо сначала освободить каждый массив, а уже потом и массив массивов. Что самое интересное, не произойдет двойного удаления по нулевым индексам массивов. Формального объяснения этому нет, но все же лучше запомнить следующее правило:

**Каждый вызов new требует вызова delete, каждый вызов new[] требует вызова delete[]**


#### The best practices

Заметим, что первые два цикла можно свернуть в одну строку. 

`int** matrix = new int*[3]{new int[3]{0, 1, 2}, new int[3]{1, 2, 3}, new int[3]{2, 3, 4}};`

Конечно, не так красиво как в питоне, так как в C++ статическая типизация, но можно же! (пожалуйста, не делайте так никогда)

А все удаление можно свернуть в такую строку

`delete[] matrix[0], delete[] matrix[1], delete[] matrix[2], delete matrix[];`

А вот так вообще никогда нельзя делать!!!

