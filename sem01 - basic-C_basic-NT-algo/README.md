# Семинар первый

## Базовые примеры программ на C++


### Пример <<Hello, world!>> на C++:
```cpp
#include <iostream>
using namespace std;

int main() {
  cout << "Hello, world!" << '\n';
  return 0;
}
````

Теперь разберем данный пример по строкам:

1. `#include <iostream>` Грубо говоря, позволяет нам использовать ввод/вывод из/в консоль в программе: `cin/cout`.

2. `using namespace std;` Так как все встроенные функции, а также переменные, обозначающие ввод/вывод из/в консоль лежат в каких-то определенных местах (далее узнаем, что это называется пространство имен). Так как компилятор не знает по умолчанию, из какого именно модуля мы хотим вызвать переменную или функцию, ему необходимо это указывать посредством написания префикса `std::` перед всеми неизвестными ему объектами в коде. Данная же строка позволяет избавиться от такой записи.

**Замечание:** в дальнейшем мы поймем, почему данная строка является крайне плохим тоном в коде, поэтому старайтесь сразу от нее отучаться.

3. `int main() {...}` Любая программа на языках Си и C++ состоит из функций. Анализ и исполнение любой программы начинаются с данной функции. Более подробно о синтаксисе использования функций в дальнейших семинарах.

4. `cout << "Hello, world!" << '\n';` Собственно содержательная часть программы. 

* `cout` Обозначает, что далее будет вывод в консоль IDE (среда, где вы пишете код) или терминала. В отсутствие второй строки необходимо писать `std::cout`.

* `<<` Это оператор вывода в консоль. Позднее мы познакомимся с понятием перегрузки и поймем, почему в большинстве случаев это оператор побитового сдвига.

* `"Hello, world!"` Это сама строка, которую мы будем выводить на печать.

* `'\n` Это символ перевода строки, то есть все, что выводится дальше, будет напечатано со следующей строки.

5. `return 0` У функции `main` есть возвращаемое значение типа `int`. Программа завершится успешно, если вернется ноль. Если же вернуть другое число, то это будет считаться ошибкой исполнения программы (раньше так сигнализировали об ошибке, а ее коду придавали смысловое значение). Данная строка необязательна, начиная с версии C99, и, вроде бы, во всех версиях языка C++.

### Пример A+B на C++

Так как языки Си и C++ компилируемые и обладают статической типизацией, вам необходимо указать типы данных для всех переменных в коде. [Основные типы данных](https://docs.microsoft.com/ru-ru/cpp/cpp/cpp-type-system-modern-cpp?view=vs-2019#fundamental-built-in-types) в языке C++. 

```cpp
#include <iostream>

int main() {
  int a; //type of a is required, in other case verdict is Compilation error (CE)
  int b; //int a, b; is also possible, moreover, int a = 0, b = 0; is also possible
         //but the last variant is bad, because in huge projects you will have a lot of variables
  std::cin >> a >> b; //using cin means reading, therefore "arrows change its direction"
  std::cout << a + b << '\n';
}
````

Как видите, перед объявлением переменных обязательно указать их тип. Вывод типа выражения после применения оператора (в данном случае сложения) осуществляется автоматически. Подробнее обо всех операторах в языке C++ можно посмотреть [тут](https://en.cppreference.com/w/cpp/language/operator_precedence).

У переменной в языке C++ есть не только тип, но и область видимости/действия. Переменные действительны не во всем коде программы, в большинстве случаев они действительны внутри блока программы, который обозначается фигурными скобками `{/* it is one block of code */}`.

## Управляющие конструкции в C++

### Ветвление в C++

```cpp
if (/* condition 1 */) {
  /* block 1 */
} else if (/* condition 2 */) {
  /* block 2 */
} else {
  /* block 3 */
}
````

Так как в языке C++ (да и в любом уважающем себя языке программирования) есть логический тип данных *bool*, он используется, чтобы проверить выражение на истинность. Собственно, если выполнено первое условие, то выполнится первый блок. Если же выполнено условие 2, то второй. Если не выполнены ни первое, ни второе условие, то выполнится третий блок.

#### Пример программы

```cpp
#include <iostream>

int main() {
  int a;
  std::cin >> a;
  if (a < 0) {
  	std::cout << "a is negative\n";
  } else if (a > 0) {
  	std::cout << "a is positive\n";
  } else {
  	std::cout << "a is zero\n";
  }
}
````

### Циклы в C++

#### Цикл for

Цикл for чаще всего используется для того, чтобы пробежать массив или другой контейнер или же как цикл со счетчиком. Его общий вид:

```cpp
for (/* init */; /* condition */; /* expression */) {
	/* block */
}
````

* На стадии *init* обычно инициализируют переменную счетчик или еще какие-либо переменные, доступные в области *block*. Она может быть пустой.

* На стадии *condition* проверяется условие, которое если неверно, то цикл прекращается. Может быть пустым, что приводит иногда к вечному циклу.

* На стадии *expression* обычно инкрементируют или модифицируют переменную-счетчик, но можно делать больше инструкций. Может быть пустым.

##### Пример вечного цикла

```cpp
#include <iostream>

int main() {
  for (unsigned int i = 1; ; ++i) {
  	std::cout << "Infinite loop, iteration " << i << '\n';
  }
}
````
##### Пример стандартного цикла

Данный код выводит все четные целые числа из полуинтервала *[0, n)*.

```cpp
#include <iostream>

int main() {
  int n;
  std::cin >> n;
  for (int i = 0; i < n; ++i) {
  	if (i % 2 == 0) {
  		std::cout << i << ' ';
  	}
  }
}
````

#### Цикл while

Цикл while чаще всего используется для того, чтобы делать нечто, пока выражение истинно. Его общий вид:

```cpp
while (/* condition */) {
	/* block */
}
````

Для стадии *condition* верно все то же самое, что и для цикла *for* на той же стадии.

##### Пример вечного цикла

```cpp
#include <iostream>

int main() {
  while () {
  	std::cout << "A";
  }
}
````
##### Пример стандартного цикла

Данный код выводит все четные целые числа из полуинтервала *[0, n)*.

```cpp
#include <iostream>

int main() {
  int n;
  std::cin >> n;
  int i = 0;
  while (i < n) {
  	if (i % 2 == 0) {
  		std::cout << i << ' ';
  	}
  	++i;
  	//if you hate readers of your code, you can write block in one srting: (std::cout << i << ' '), (i += 2);
  }
}
````

Как видите, данный код объемнее, чем с циклом *for*, но это не значит, что он всегда удобнее. В дальнейшем мы столкнемся с случаем, когда практичнее цикл *while*.

## Ссылки и константы

### Константы

Бывает такая ситуация, что вы явно хотите сказать читателю вашего кода, что некоторое значение является константным. Это нужно для того, чтобы не плодить в программе магические константы. Числовые и строковые константы тоже таковыми являются.

#### Пример использования констант

```cpp
#include <iostream>

int main() {
  int n;
  std::cin >> n;
  const int mod = 3;
  int i = 0;
  for (int i = 0; i < n; ++i) {
  	if (i % mod == 0) {
  		std::cout << i << ' ';
  	}
  }
}
````

### Ссылки

Очень важная концепция языка C++, которой нет в языке Си - ссылки. Грубо говоря, ссылка - синоним имени переменной. То есть при модификации переменной, изменяются значения всех переменных, что на нее ссылаются. Более того, при модификации ссылки изменяется и значение переменной. Поэтому можно сказать, что переменная и ссылка на нее - единое целое. При этом, так как ссылка по сути указывает на область в памяти, где лежит переменная, нельзя создавать обычные ссылки на *объекты без имени*.

#### Пример использования ссылок

```cpp
#include <iostream>

int main() {
  int x = 5;
  int& y = x; //y is reference to x
  std::cout << x << ' ' << y << '\n'; //5 5
  x *= 2; //equivalent of x = x * 2;
  std::cout << x << ' ' << y << '\n'; //10 10
  y = 3;
  std::cout << x << ' ' << y << '\n'; //3 3
}
````

### I have const, I have reference...

Казалось бы, ссылки и константы, что может быть между ними общего... Язык C++ был создан для того, чтобы удивлять, так что понеслась.

Ссылки на константу говорят о том, что переменная, на которую ссылаются, не будет меняться на протяжении работы программы. Казалось бы, зачем это нужно. На самом деле это нам пригодится в функциях очень сильно, но пока что ознакомимся с синтаксисом.

#### Пример ссылки на константу

```cpp
#include <iostream>

int main() {
  const int& x = 5; //note that 5 is constant, but for constructions like this it is OK
  std::cout << x << '\n'; //5
  in
  x *= 2; //compilation error, because x can't be modified
}
````

## Простейшие алгоритмы на теорию чисел

### Факторизация

Факторизация - процесс разложения натурального числа на простые множители в соответствующих степенях. Основная теорема арифметики утверждает, что для любого натурального числа такое разложение существует и единственно с точностью до перестановки множителей. Например, *36 = 2 * 2 * 3 * 3*. Суть алгоритма в переборе чисел от 2 до *n* и если число является делителем, то выписываем его. Сложность такого алгоритма линейная, так как число может оказаться уже простым. Поэтому стоит заметить факт из школьного курса математики, что делители ходят парами, то есть если простое число *p* входит в разложение, то оно не может быть больше, чем корень из числа, округленный вверх. Поэтому достаточно перебирать не от 2 до n, а от 2 до корня из *n*.

Заготовка алгоритма:

```cpp
#include <iostream>
#include <cmath> //for using sqrt (square root) function

int main() {
  int n;
  std::cin >> n;
  for (int i = 2; i <= std::sqrt(n); ++i) { //or i * i <= n
  	/* your code goes here */
  }
}
````

### НОД и НОК

Из школьного курса математики вам уже известно, что такое НОД (gcd) и НОК (lcm). Более того, наверняка вы знаете про алгоритм Евклида для подсчета НОДа. При знании НОДа можно сразу найти НОК, так как есть такая формула: *gcd(a, b) * lcm(a, b) = a * b*.

В интернете можно найти [рекурсивную реализацию алгоритма Евклида](https://e-maxx.ru/algo/euclid_algorithm). На семинаре же мы с вами напишем ее с использованием циклов.

### Бинарное возведение в степень

Для возведения числа в степень мы можем его просто домножить само на себя нужное число раз. Но это может быть слишком долго, если возводить, например, матрицы в большую степень. Для того, чтобы делать возведение в степень не за линейное, а за логарифмическое время, заметим, что если *b* четное, то *a^b = a^(b/2) * a^(b/2)*, то есть уменьшить число умножений вдвое. Если же *b* нечетное, то *a^b = a^(b-1) * a* - на этой стадии уже можно делить *b - 1* пополам нацело.

### Арифметика по модулю

Иногда надо вычислить результат арифметического действия по модулю *p*, то есть получить его остаток от деления на *p*. Для сложения, вычитания и умножения это тривиально, так как:

* *(a + b) % p = (a % p) + (b % p)*

* *(a - b) % p = (a % p) - (b % p)*

* *(a * b) % p = (a % p) * (b % p)*

К сожалению, с делением все обстоит малость труднее. Деление - это умножение на число, обратное к данному: *a * a^(-1) = 1*. К сожалению, не для любого модуля обратный элемент существует. Есть теорема о том, что для любого *a* существует обратный к нему тогда и только тогда, когда *p* - простое. Поиск обратного элемента по модулю уже задача потруднее. Для ее решения есть два метода. Первый способ через малую теорему ферма (на следующем семинаре), а второй - через [расширенный алгоритм Евклида](https://ru.wikipedia.org/wiki/Алгоритм_Евклида#Линейные_диофантовы_уравнения) (его разберем через несколько недель, когда будут пройдены функции и рекурсия). Если вам очень хочется разобраться самим, то найти его рекурсивную реализацию в интернете нетрудно, при этом есть утверждение, что любую рекурсию можно написать без ее использования через циклы.
